<!DOCTYPE html>
<html>
<head>
    <title>3D Cube with Segments</title>
    <style>
        body { margin: 0;
        background-color: white; }
        canvas { display: block; }
        #cube-container {
            width: 100%;
            height: 100vh;
        }
        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255,255,255,0.8);
            padding: 10px;
            border-radius: 5px;
        }
        .segment-control {
            margin: 5px 0;
        }
        .enter-button {
            margin-top: 10px;
            padding: 5px 15px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        .enter-button:hover {
            background: #45a049;
        }
        .theme-button {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px 20px;
            background: #333;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <button class="theme-button" onclick="toggleTheme()">Dark Mode</button>
    <div id="cube-container">
        <div class="controls">
            <h3>Segment Colors</h3>
            <div class="segment-control">
                <label>Segment Name (AB, BC, CD, etc): </label>
                <input type="text" id="segmentName" placeholder="Enter segment name">
            </div>
            <div class="segment-control">
                <label>Color: </label>
                <input type="color" id="segmentColor">
            </div>
            <button class="enter-button" onclick="updateSegmentColorFromInput()">Enter</button>
            <h3>Side Colors</h3>
            <div class="segment-control">
                <label>Side Name (ABCD, EFGH, etc): </label>
                <input type="text" id="sideName" placeholder="Enter side name">
            </div>
            <div class="segment-control">
                <label>Color: </label>
                <input type="color" id="sideColor">
            </div>
            <button class="enter-button" onclick="updateSideColorFromInput()">Enter</button>
            <h3>Diagonal Colors</h3>
            <div class="segment-control">
                <label>Diagonal Name (AC, BD, EG, FH, etc): </label>
                <input type="text" id="diagonalName" placeholder="Enter diagonal name">
            </div>
            <div class="segment-control">
                <label>Color: </label>
                <input type="color" id="diagonalColor">
            </div>
            <button class="enter-button" onclick="updateDiagonalColorFromInput()">Enter</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let segments = {};
        let faces = {};
        let diagonals = {};
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let isDarkMode = false;
        let isInside = false;

        // Wait for DOM content to load
        document.addEventListener('DOMContentLoaded', () => {
            init();
            animate();
        });

        function toggleTheme() {
            isDarkMode = !isDarkMode;
            const button = document.querySelector('.theme-button');
            if (isDarkMode) {
                document.body.style.backgroundColor = 'black';
                scene.background = new THREE.Color(0x000000);
                button.textContent = 'Light Mode';
            } else {
                document.body.style.backgroundColor = 'white';
                scene.background = new THREE.Color(0xffffff);
                button.textContent = 'Dark Mode';
            }
        }

        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);

            // Setup camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            
            // Setup renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('cube-container').appendChild(renderer.domElement);

            // Create cube vertices
            const vertices = [
                new THREE.Vector3(-1, -1, -1),  // A: 0
                new THREE.Vector3(1, -1, -1),   // B: 1
                new THREE.Vector3(1, -1, 1),    // C: 2
                new THREE.Vector3(-1, -1, 1),   // D: 3
                new THREE.Vector3(-1, 1, -1),   // E: 4
                new THREE.Vector3(1, 1, -1),    // F: 5
                new THREE.Vector3(1, 1, 1),     // G: 6
                new THREE.Vector3(-1, 1, 1)     // H: 7
            ];

            // Create segments
            const segmentPairs = [
                ['AB', [0,1]], ['BC', [1,2]], ['CD', [2,3]], ['DA', [3,0]],
                ['EF', [4,5]], ['FG', [5,6]], ['GH', [6,7]], ['HE', [7,4]],
                ['AE', [0,4]], ['BF', [1,5]], ['CG', [2,6]], ['DH', [3,7]]
            ];

            // Create diagonals (initially invisible)
            const diagonalPairs = [
                ['AC', [0,2]], ['BD', [1,3]], ['EG', [4,6]], ['FH', [5,7]],
                ['ED', [4,3]], ['AH', [0,7]], ['FC', [5,2]], ['GB', [6,1]],
                ['HC', [7,2]], ['DG', [3,6]], ['EB', [4,1]], ['FA', [5,0]],
                ['EC', [4,2]], ['FD', [5,3]], ['HB', [7,1]], ['GA', [6,0]]
            ];

            // Create a group to hold all segments and faces
            const cubeGroup = new THREE.Group();

            // Create faces
            const faceDefinitions = {
                'ABCD': [[0,1,2], [0,2,3]],
                'EFGH': [[4,5,6], [4,6,7]],
                'AEBF': [[0,1,5], [0,5,4]],
                'BFCG': [[1,2,6], [1,6,5]],
                'CGHD': [[2,3,7], [2,7,6]],
                'DHAE': [[3,0,4], [3,4,7]]
            };

            for (let [faceName, triangles] of Object.entries(faceDefinitions)) {
                const geometry = new THREE.BufferGeometry();
                const faceVertices = [];
                
                triangles.forEach(triangle => {
                    triangle.forEach(vertexIndex => {
                        faceVertices.push(vertices[vertexIndex].x, vertices[vertexIndex].y, vertices[vertexIndex].z);
                    });
                });
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(faceVertices, 3));
                geometry.computeVertexNormals();
                
                const material = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.2,
                    side: THREE.DoubleSide
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                faces[faceName] = mesh;
                cubeGroup.add(mesh);
            }

            // Create vertex labels
            const vertexLabels = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
            vertices.forEach((vertex, index) => {
                const sprite = makeTextSprite(vertexLabels[index]);
                sprite.position.set(vertex.x * 1.1, vertex.y * 1.1, vertex.z * 1.1);
                cubeGroup.add(sprite);
            });

            segmentPairs.forEach(([name, [start, end]]) => {
                const points = [vertices[start], vertices[end]];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ 
                    color: 0x000000,
                    linewidth: 2
                });
                const line = new THREE.Line(geometry, material);
                segments[name] = line;
                cubeGroup.add(line);
            });

            // Create diagonals (initially invisible)
            diagonalPairs.forEach(([name, [start, end]]) => {
                const points = [vertices[start], vertices[end]];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ 
                    color: 0x000000,
                    linewidth: 2,
                    visible: false
                });
                const line = new THREE.Line(geometry, material);
                diagonals[name] = line;
                cubeGroup.add(line);
            });

            scene.add(cubeGroup);

            // Add event listeners
            renderer.domElement.addEventListener('mousedown', onMouseDown, false);
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('mouseup', onMouseUp, false);
            renderer.domElement.addEventListener('wheel', onMouseWheel, false);
            window.addEventListener('resize', onWindowResize, false);
        }

        function makeTextSprite(message) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 64;
            canvas.height = 64;

            context.font = '32px Arial';
            context.fillStyle = 'black';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(message, 32, 32);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(0.3, 0.3, 1);
            return sprite;
        }

        function updateSegmentColorFromInput() {
            const segmentName = document.getElementById('segmentName').value.toUpperCase();
            const color = document.getElementById('segmentColor').value;
            if (segments[segmentName]) {
                updateSegmentColor(segmentName, color);
            } else {
                alert('Invalid segment name. Please use: AB, BC, CD, DA, EF, FG, GH, HE, AE, BF, CG, or DH');
            }
        }

        function updateDiagonalColorFromInput() {
            const diagonalName = document.getElementById('diagonalName').value.toUpperCase();
            const color = document.getElementById('diagonalColor').value;
            if (diagonals[diagonalName]) {
                diagonals[diagonalName].material.visible = true;
                diagonals[diagonalName].material.color.setStyle(color);
            } else {
                alert('Invalid diagonal name. Please use: AC, BD, EG, FH, ED, AH, FC, GB, HC, DG, EB, FA, EC, FD, HB, or GA');
            }
        }

        function updateSideColorFromInput() {
            const sideName = document.getElementById('sideName').value.toUpperCase();
            const color = document.getElementById('sideColor').value;
            
            const validSides = {
                'ABCD': ['AB', 'BC', 'CD', 'DA'],
                'EFGH': ['EF', 'FG', 'GH', 'HE'],
                'AEBF': ['AB', 'BF', 'EF', 'AE'],
                'BFCG': ['BC', 'CG', 'FG', 'BF'],
                'CGHD': ['CD', 'DH', 'GH', 'CG'],
                'DHAE': ['DA', 'AE', 'HE', 'DH']
            };

            if (validSides[sideName]) {
                validSides[sideName].forEach(segment => {
                    updateSegmentColor(segment, color);
                });
                
                if (faces[sideName]) {
                    faces[sideName].material.color.setStyle(color);
                    faces[sideName].material.opacity = 0.3;
                }
            } else {
                alert('Invalid side name. Please use: ABCD, EFGH, AEBF, BFCG, CGHD, or DHAE');
            }
        }

        function updateSegmentColor(segmentName, color) {
            if (segments[segmentName]) {
                segments[segmentName].material.color.setStyle(color);
            }
        }

        function onMouseDown(event) {
            event.preventDefault();
            isDragging = true;
            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }

        function onMouseMove(event) {
            event.preventDefault();
            if (!isDragging) return;

            const deltaMove = {
                x: event.clientX - previousMousePosition.x,
                y: event.clientY - previousMousePosition.y
            };

            scene.rotation.y += deltaMove.x * 0.005;
            scene.rotation.x += deltaMove.y * 0.005;

            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }

        function onMouseUp(event) {
            event.preventDefault();
            isDragging = false;
        }

        function onMouseWheel(event) {
            event.preventDefault();
            
            const distanceFromCenter = camera.position.length();
            const zoomSpeed = 0.1;
            const zoomFactor = event.deltaY > 0 ? 1 + zoomSpeed : 1 - zoomSpeed;
            
            camera.position.multiplyScalar(zoomFactor);
            
            if (distanceFromCenter < 1.2 && !isInside) {
                isInside = true;
                Object.values(faces).forEach(face => {
                    face.material.opacity = 0.0;
                });
            }
            
            if (distanceFromCenter >= 1.2 && isInside) {
                isInside = false;
                Object.values(faces).forEach(face => {
                    face.material.opacity = 0.2;
                });
            }
            
            if (distanceFromCenter > 10) {
                camera.position.normalize().multiplyScalar(10);
            }
            if (distanceFromCenter < 0.5) {
                camera.position.normalize().multiplyScalar(0.5);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
    </script>
    <script src="../JavaScript/holoschool.js"></script>
</body>
</html>
