<!DOCTYPE html>
<html>
<head>
    <title>3D Holographic Tetrahedron</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #tetrahedron-container {
            width: 100%;
            height: 100vh;
        }
        .properties {
            display: flex;
            flex-direction: column;
            position: absolute;
        }
        .properties > * {
            margin: 5px;
        }
    </style>
</head>
<body>
    <div class="properties">
        <h2>Properties</h2>
        <label for="colorPicker">face color</label>
        <input type="color" id="colorPicker" value="#000000" onchange="changeColorFace()">
        <label for="edgePicker">edge color</label>
        <input type="color" id="edgePicker" value="#000000" onchange="changeColorEdge()">
        <label for="letterColor">letter color</label>
        <input type="color" id="letterColor" value="#000000" onchange="changeColorLetter()">
    </div>
    <div id="tetrahedron-container"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        function changeColorFace() {
            material.color.set(colorPicker.value);
        }
        function changeColorEdge() {
            lineMaterial.color.set(edgePicker.value);
            mediatorMaterial.color.set(edgePicker.value);
            heightMaterial.color.set(edgePicker.value);
        }
        function changeColorLetter() {
            let vertexNames = document.getElementsByClassName('vertex-label');
            for(let i = 0; i < vertexNames.length; i++) {
                vertexNames[i].style.color = letterColor.value;
            }
        }

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ alpha: true });
        const container = document.getElementById('tetrahedron-container');
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        const minDimension = Math.min(container.clientWidth, container.clientHeight);
        const size = minDimension * 0.002;

        // Create tetrahedron geometry
        const geometry = new THREE.TetrahedronGeometry(size);
        const material = new THREE.MeshPhongMaterial({
            color: 0x9acffff,
            transparent: true,
            opacity: 0.3,
            specular: 0x555555,
            shininess: 30,
            side: THREE.DoubleSide
        });
        const tetrahedron = new THREE.Mesh(geometry, material);

        // Add edges
        const edges = new THREE.EdgesGeometry(geometry);
        const lineMaterial = new THREE.LineBasicMaterial({ 
            color: 0x7fceff,
            linewidth: 2
        });
        const wireframe = new THREE.LineSegments(edges, lineMaterial);
        tetrahedron.add(wireframe);

        // Add mediators
        const mediatorMaterial = new THREE.LineBasicMaterial({
            color: 0x7fceff,
            linewidth: 1,
            opacity: 0.5
        });

        // Material for height lines
        const heightMaterial = new THREE.LineBasicMaterial({
            color: 0x7fceff,
            linewidth: 1,
            opacity: 0.5
        });

        // Get face vertices
        const positions = geometry.attributes.position;
        const faces = [
            [0, 1, 2], // Face 1
            [0, 2, 3], // Face 2
            [0, 1, 3], // Face 3
            [1, 2, 3]  // Face 4
        ];

        // For each face, calculate and draw mediators and heights
        faces.forEach(face => {
            const v1 = new THREE.Vector3().fromBufferAttribute(positions, face[0]);
            const v2 = new THREE.Vector3().fromBufferAttribute(positions, face[1]);
            const v3 = new THREE.Vector3().fromBufferAttribute(positions, face[2]);

            // Calculate midpoints of each edge
            const m1 = new THREE.Vector3().addVectors(v1, v2).multiplyScalar(0.5);
            const m2 = new THREE.Vector3().addVectors(v2, v3).multiplyScalar(0.5);
            const m3 = new THREE.Vector3().addVectors(v3, v1).multiplyScalar(0.5);

            // Create mediator lines
            const mediatorGeometry1 = new THREE.BufferGeometry().setFromPoints([v1, m2]);
            const mediatorGeometry2 = new THREE.BufferGeometry().setFromPoints([v2, m3]);
            const mediatorGeometry3 = new THREE.BufferGeometry().setFromPoints([v3, m1]);

            const mediator1 = new THREE.Line(mediatorGeometry1, mediatorMaterial);
            const mediator2 = new THREE.Line(mediatorGeometry2, mediatorMaterial);
            const mediator3 = new THREE.Line(mediatorGeometry3, mediatorMaterial);

            tetrahedron.add(mediator1);
            tetrahedron.add(mediator2);
            tetrahedron.add(mediator3);

            // Calculate gravity center of the face
            const gravityCenter = new THREE.Vector3()
                .addVectors(v1, v2)
                .add(v3)
                .multiplyScalar(1/3);

            // Find the vertex not in this face
            let topVertex = null;
            for(let i = 0; i < positions.count; i++) {
                if(!face.includes(i)) {
                    topVertex = new THREE.Vector3().fromBufferAttribute(positions, i);
                    break;
                }
            }

            // Create height line from top vertex to gravity center
            const heightGeometry = new THREE.BufferGeometry().setFromPoints([
                topVertex,
                gravityCenter
            ]);
            const heightLine = new THREE.Line(heightGeometry, heightMaterial);
            tetrahedron.add(heightLine);
        });

        // Add vertex labels
        const vertices = geometry.attributes.position;
        const vertexLabels = ['A', 'B', 'C', 'D'];
        for(let i = 0; i < vertices.count; i++) {
            const vertexLabel = document.createElement('div');
            vertexLabel.className = 'vertex-label';
            vertexLabel.textContent = vertexLabels[i];
            vertexLabel.style.position = 'absolute';
            vertexLabel.style.color = 'black';
            vertexLabel.style.fontSize = '16px';
            document.body.appendChild(vertexLabel);
        }

        scene.add(tetrahedron);

        // Add lights
        const light1 = new THREE.DirectionalLight(0xffffff, 1);
        light1.position.set(1, 1, 1);
        scene.add(light1);

        const light2 = new THREE.DirectionalLight(0xffffff, 0.5);
        light2.position.set(-1, -1, -1);
        scene.add(light2);

        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        camera.position.z = 5;

        // Mouse rotation controls
        let mouseDown = false;
        let mouseX = 0;
        let mouseY = 0;

        container.addEventListener('mousedown', (e) => {
            mouseDown = true;
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        container.addEventListener('mouseup', () => {
            mouseDown = false;
        });

        container.addEventListener('mousemove', (e) => {
            if (mouseDown) {
                const deltaX = e.clientX - mouseX;
                const deltaY = e.clientY - mouseY;
                
                tetrahedron.rotation.y += deltaX * 0.01;
                tetrahedron.rotation.x += deltaY * 0.01;
                
                mouseX = e.clientX;
                mouseY = e.clientY;
            }
        });

        // Animation
        function animate() {
            requestAnimationFrame(animate);

            // Update vertex label positions
            for(let i = 0; i < vertices.count; i++) {
                const vertexLabel = document.getElementsByClassName('vertex-label')[i];
                const vector = new THREE.Vector3();
                vector.fromBufferAttribute(vertices, i);
                tetrahedron.localToWorld(vector.clone());
                const position = vector.project(camera);
                vertexLabel.style.left = (position.x * 0.5 + 0.5) * container.clientWidth + 'px';
                vertexLabel.style.top = (-position.y * 0.5 + 0.5) * container.clientHeight + 'px';
            }

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });

        animate();
    </script>
</body>
</html>
